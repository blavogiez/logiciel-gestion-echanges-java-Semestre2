if (hostCombo.get(i).canBeMatched(this.getYear()) && permutedGuests.get(i).canBeMatched(this.getYear())) {
	Exchange e = new Exchange(this.getYear(), hostCombo.get(i), permutedGuests.get(i));
	// The current exchange being in history has no real sense :
	// It just means the user has loaded it twice at least
	// This way we'll ignore because there's only one country visit between two countries possible per year.
	// It is hard to conceive this fact
	//System.out.println(e) ;
	
	if (
	PeopleManager.isInHistory(e) ||
	PeopleManager.isBanned(e) ||
	// Checking if the person is already matched in the current year in the history
	PeopleManager.isMatchedThisYearInHistory(e.getHost(), e.getYear()) ||
	PeopleManager.isMatchedThisYearInHistory(e.getGuest(), e.getYear())) {
		// Globally, if the exchange or its containing persons are not valid, the pair is skipped
		sum = Double.MAX_VALUE;
		break;
	} else {
		current.add(e);
	}
	sum += e.getAffinityScore();
	
} else {
	// If one of the persons cannot be matched, skip this pairing
	sum = Double.MAX_VALUE;
	break;
}
